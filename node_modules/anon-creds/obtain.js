const schnorr = require('./schnorr-proof')
const curve = require('./curve')
const Credential = require('./credential')

module.exports = ObtainingProtocol

const G1 = curve.G1
const F = curve.F
const rand = curve.randomScalar

function ObtainingProtocol (attr) {
  if (!(this instanceof ObtainingProtocol)) return new ObtainingProtocol()

  const cred = new Credential(attr)

  function obtain () {
    const alpha = rand()
    cred.kappa = rand()

    cred.S = G1.mulScalar(init.S_, alpha)
    cred._S[0] = G1.mulScalar(init.S0_, alpha)

    const R1 = G1.mulScalar(cred.S, kappa1)
    const R2 = G1.mulScalar(cred.S[0], cred.k[0])
    const R = G1.add(R1, R2)

    const prover = schnorr([cred.S, cred.S[0]])
    var proof = prover.genProof([cred.kappa, cred.k[0]])

    cred.store = storeCredential(cred.S, cred.S[0], cred.kappa, cred.k)

    const reponse = {
      S: cred.S,
      S0: cred.S[0],
      R,
      proof
    }

    return {
      cred,
      response
    }
  }
}

function storeCredential () {
  return (final) => {
    cred.kappa = F.normalize(F.add(cred.kappa, final.kappa))
    const K = final.K
    const _S = [cred.S[0]].concat(final._S)
    const T = final.T

    const C = _S.reduce((acc, el, i) => G1.add(acc, G1.mulScalar(el, cred.k[i])),
      G1.add(K, G1.mulScalar(cred.S, cred.kappa)))

    const credential = {
      k,
      kappa,
      K,
      cred.S,
      _S,
      T,
      C
    }

    return credential
  }
}
